diff --git a/src/cmd/addr2line/skip.go b/src/cmd/addr2line/skip.go
new file mode 100644
index 0000000..7fd4b0e
--- /dev/null
+++ b/src/cmd/addr2line/skip.go
@@ -0,0 +1,3 @@
+// +build !clive
+
+package main
diff --git a/src/cmd/api/skip.go b/src/cmd/api/skip.go
new file mode 100644
index 0000000..7fd4b0e
--- /dev/null
+++ b/src/cmd/api/skip.go
@@ -0,0 +1,3 @@
+// +build !clive
+
+package main
diff --git a/src/cmd/asm/skip.go b/src/cmd/asm/skip.go
new file mode 100644
index 0000000..7fd4b0e
--- /dev/null
+++ b/src/cmd/asm/skip.go
@@ -0,0 +1,3 @@
+// +build !clive
+
+package main
diff --git a/src/cmd/cgo/skip.go b/src/cmd/cgo/skip.go
new file mode 100644
index 0000000..7fd4b0e
--- /dev/null
+++ b/src/cmd/cgo/skip.go
@@ -0,0 +1,3 @@
+// +build !clive
+
+package main
diff --git a/src/cmd/compile/skip.go b/src/cmd/compile/skip.go
new file mode 100644
index 0000000..7fd4b0e
--- /dev/null
+++ b/src/cmd/compile/skip.go
@@ -0,0 +1,3 @@
+// +build !clive
+
+package main
diff --git a/src/cmd/cover/skip.go b/src/cmd/cover/skip.go
new file mode 100644
index 0000000..7fd4b0e
--- /dev/null
+++ b/src/cmd/cover/skip.go
@@ -0,0 +1,3 @@
+// +build !clive
+
+package main
diff --git a/src/cmd/dist/build.go b/src/cmd/dist/build.go
index 0cdb7d6..14c689c 100644
--- a/src/cmd/dist/build.go
+++ b/src/cmd/dist/build.go
@@ -69,6 +69,7 @@ var okgoos = []string{
 	"openbsd",
 	"plan9",
 	"windows",
+	"clive",
 }
 
 // find reports the first index of p in l[0:n], or else -1.
diff --git a/src/cmd/dist/skip.go b/src/cmd/dist/skip.go
new file mode 100644
index 0000000..7fd4b0e
--- /dev/null
+++ b/src/cmd/dist/skip.go
@@ -0,0 +1,3 @@
+// +build !clive
+
+package main
diff --git a/src/cmd/doc/skip.go b/src/cmd/doc/skip.go
new file mode 100644
index 0000000..39752b4
--- /dev/null
+++ b/src/cmd/doc/skip.go
@@ -0,0 +1,5 @@
+// +build !clive
+
+package main
+
+
diff --git a/src/cmd/fix/skip.go b/src/cmd/fix/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/fix/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/go/main.go b/src/cmd/go/main.go
index b0d7448..825f26d 100644
--- a/src/cmd/go/main.go
+++ b/src/cmd/go/main.go
@@ -516,7 +516,7 @@ func matchPackages(pattern string) []string {
 		have["runtime/cgo"] = true // ignore during walk
 	}
 	var pkgs []string
-
+	var skip []string
 	for _, src := range buildContext.SrcDirs() {
 		if (pattern == "std" || pattern == "cmd") && src != gorootSrc {
 			continue
@@ -554,12 +554,23 @@ func matchPackages(pattern string) []string {
 			if !match(name) {
 				return nil
 			}
-			_, err = buildContext.ImportDir(path, 0)
+			var p *build.Package
+			p, err = buildContext.ImportDir(path, 0)
 			if err != nil {
+				if p != nil && p.NotToBuild {
+					skip = append(skip, path+"/")
+					return nil
+				}
 				if _, noGo := err.(*build.NoGoError); noGo {
 					return nil
 				}
 			}
+			for _, s := range skip {
+				if strings.HasPrefix(path, s) {
+					// fmt.Fprintf(os.Stderr, "skip child %s\n", path)
+					return nil
+				}
+			}
 			pkgs = append(pkgs, name)
 			return nil
 		})
@@ -597,6 +608,7 @@ func matchPackagesInFS(pattern string) []string {
 	match := matchPattern(pattern)
 
 	var pkgs []string
+	var skip []string
 	filepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {
 		if err != nil || !fi.IsDir() {
 			return nil
@@ -624,12 +636,23 @@ func matchPackagesInFS(pattern string) []string {
 		if !match(name) {
 			return nil
 		}
-		if _, err = build.ImportDir(path, 0); err != nil {
+		var p *build.Package
+		if p, err = build.ImportDir(path, 0); err != nil {
+			if p != nil && p.NotToBuild {
+				skip = append(skip, path+"/")
+				return nil
+			}
 			if _, noGo := err.(*build.NoGoError); !noGo {
 				log.Print(err)
 			}
 			return nil
 		}
+		for _, s := range skip {
+			if strings.HasPrefix(path, s) {
+				// fmt.Fprintf(os.Stderr, "skip child %s\n", path)
+				return nil
+			}
+		}
 		pkgs = append(pkgs, name)
 		return nil
 	})
diff --git a/src/cmd/go/pkg.go b/src/cmd/go/pkg.go
index 601c303..2d3ecc9 100644
--- a/src/cmd/go/pkg.go
+++ b/src/cmd/go/pkg.go
@@ -95,6 +95,8 @@ type Package struct {
 	coverMode    string               // preprocess Go source files with the coverage tool in this mode
 	coverVars    map[string]*CoverVar // variables created by coverage analysis
 	omitDWARF    bool                 // tell linker not to write DWARF information
+
+	NotToBuild bool `json:",omitempty"` // package is a skip
 }
 
 // CoverVar holds the name of the generated coverage variables targeting the named file.
@@ -137,6 +139,7 @@ func (p *Package) copyBuild(pp *build.Package) {
 	p.TestImports = pp.TestImports
 	p.XTestGoFiles = pp.XTestGoFiles
 	p.XTestImports = pp.XTestImports
+	p.NotToBuild = pp.NotToBuild 
 }
 
 // A PackageError describes an error loading information about a package.
@@ -468,7 +471,9 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package
 	// The localPrefix is the path we interpret ./ imports relative to.
 	// Synthesized main packages sometimes override this.
 	p.localPrefix = dirToImportPath(p.Dir)
-
+	if p.NotToBuild && err == nil {
+		err = errors.New("package skip")
+	}
 	if err != nil {
 		p.Incomplete = true
 		err = expandScanner(err)
@@ -929,6 +934,8 @@ func packages(args []string) []*Package {
 	return pkgs
 }
 
+var skips []string
+
 // packagesAndErrors is like 'packages' but returns a
 // *Package for every argument, even the ones that
 // cannot be loaded at all.
@@ -942,10 +949,19 @@ func packagesAndErrors(args []string) []*Package {
 	var pkgs []*Package
 	var stk importStack
 	var set = make(map[string]bool)
-
-	for _, arg := range args {
+Loop:	for _, arg := range args {
 		if !set[arg] {
-			pkgs = append(pkgs, loadPackage(arg, &stk))
+			p := loadPackage(arg, &stk)
+			if p.NotToBuild {
+				skips = append(skips, p.Dir+"/")
+				continue
+			}
+			for _, s := range skips {
+				if strings.HasPrefix(p.Dir, s) {
+					continue Loop
+				}
+			}
+			pkgs = append(pkgs, p)
 			set[arg] = true
 		}
 	}
diff --git a/src/cmd/go/signal_notunix.go b/src/cmd/go/signal_notunix.go
index 29aa9d8..f6d7ac6 100644
--- a/src/cmd/go/signal_notunix.go
+++ b/src/cmd/go/signal_notunix.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build plan9 windows
+// +build plan9 windows clive
 
 package main
 
diff --git a/src/cmd/go/skip.go b/src/cmd/go/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/go/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/gofmt/skip.go b/src/cmd/gofmt/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/gofmt/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/internal/obj/sym.go b/src/cmd/internal/obj/sym.go
index 37bb40b..760bdfe 100644
--- a/src/cmd/internal/obj/sym.go
+++ b/src/cmd/internal/obj/sym.go
@@ -56,6 +56,7 @@ var headers = []struct {
 	{"solaris", Hsolaris},
 	{"windows", Hwindows},
 	{"windowsgui", Hwindows},
+	{"clive", Hlinux},
 }
 
 func headtype(name string) int {
diff --git a/src/cmd/link/internal/ld/sym.go b/src/cmd/link/internal/ld/sym.go
index 652109d..e0e3b9a 100644
--- a/src/cmd/link/internal/ld/sym.go
+++ b/src/cmd/link/internal/ld/sym.go
@@ -60,6 +60,7 @@ var headers = []struct {
 	{"solaris", obj.Hsolaris},
 	{"windows", obj.Hwindows},
 	{"windowsgui", obj.Hwindows},
+	{"clive", obj.Hlinux},
 }
 
 func linknew(arch *LinkArch) *Link {
diff --git a/src/cmd/link/skip.go b/src/cmd/link/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/link/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/nm/skip.go b/src/cmd/nm/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/nm/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/objdump/skip.go b/src/cmd/objdump/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/objdump/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/old5a/skip.go b/src/cmd/old5a/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/old5a/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/old6a/skip.go b/src/cmd/old6a/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/old6a/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/old8a/skip.go b/src/cmd/old8a/skip.go
new file mode 100644
index 0000000..39752b4
--- /dev/null
+++ b/src/cmd/old8a/skip.go
@@ -0,0 +1,5 @@
+// +build !clive
+
+package main
+
+
diff --git a/src/cmd/old9a/skip.go b/src/cmd/old9a/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/old9a/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/pack/skip.go b/src/cmd/pack/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/pack/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/pprof/skip.go b/src/cmd/pprof/skip.go
new file mode 100644
index 0000000..39752b4
--- /dev/null
+++ b/src/cmd/pprof/skip.go
@@ -0,0 +1,5 @@
+// +build !clive
+
+package main
+
+
diff --git a/src/cmd/trace/skip.go b/src/cmd/trace/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/trace/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/cmd/yacc/skip.go b/src/cmd/yacc/skip.go
new file mode 100644
index 0000000..8252bee
--- /dev/null
+++ b/src/cmd/yacc/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package main
+
diff --git a/src/crypto/x509/root_clive.go b/src/crypto/x509/root_clive.go
new file mode 100644
index 0000000..c57f574
--- /dev/null
+++ b/src/crypto/x509/root_clive.go
@@ -0,0 +1,33 @@
+// Copyright 2012 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build clive
+
+package x509
+
+import "io/ioutil"
+
+// Possible certificate files; stop after finding one.
+var certFiles = []string{
+	"/sys/lib/tls/ca.pem",
+}
+
+func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {
+	return nil, nil
+}
+
+func initSystemRoots() {
+	roots := NewCertPool()
+	for _, file := range certFiles {
+		data, err := ioutil.ReadFile(file)
+		if err == nil {
+			roots.AppendCertsFromPEM(data)
+			systemRoots = roots
+			return
+		}
+	}
+
+	// All of the files failed to load. systemRoots will be nil which will
+	// trigger a specific error at verification time.
+}
diff --git a/src/go/build/build.go b/src/go/build/build.go
index db6bdcf..e04b9e7 100644
--- a/src/go/build/build.go
+++ b/src/go/build/build.go
@@ -360,6 +360,8 @@ type Package struct {
 	AllTags       []string // tags that can influence file selection in this directory
 	ConflictDir   string   // this directory shadows Dir in $GOPATH
 
+	NotToBuild bool	// the skip.go file indicates not to build this in this context
+
 	// Source files
 	GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
 	CgoFiles       []string // .go source files that import "C"
@@ -610,6 +612,20 @@ Found:
 		return p, err
 	}
 
+	for i, d := range dirs {
+		name := d.Name()
+		if name != "skip.go" {
+			continue
+		}
+		dirs[i] = dirs[len(dirs)-1]
+		dirs = dirs[:len(dirs)-1]
+		match, _, _, _ := ctxt.matchFile(p.Dir, name, true, make(map[string]bool))
+		if !match {
+			fmt.Fprintf(os.Stderr, "skip: %s\n", p.Dir)
+			p.NotToBuild = true
+		}
+		break
+	}
 	var Sfiles []string // files with ".S" (capital S)
 	var firstFile, firstCommentFile string
 	imported := make(map[string][]token.Position)
@@ -670,6 +686,10 @@ Found:
 			continue
 		}
 
+		if p.NotToBuild {
+			p.IgnoredGoFiles = append(p.IgnoredGoFiles, name)
+			continue
+		}
 		pf, err := parser.ParseFile(fset, filename, data, parser.ImportsOnly|parser.ParseComments)
 		if err != nil {
 			return p, err
@@ -777,7 +797,9 @@ Found:
 	if len(p.GoFiles)+len(p.CgoFiles)+len(p.TestGoFiles)+len(p.XTestGoFiles) == 0 {
 		return p, &NoGoError{p.Dir}
 	}
-
+	if p.NotToBuild {
+		return p, &NoGoError{p.Dir}
+	}
 	for tag := range allTags {
 		p.AllTags = append(p.AllTags, tag)
 	}
@@ -1246,6 +1268,7 @@ func splitQuoted(s string) (r []string, err error) {
 //	a comma-separated list of any of these
 //
 func (ctxt *Context) match(name string, allTags map[string]bool) bool {
+
 	if name == "" {
 		if allTags != nil {
 			allTags[name] = true
diff --git a/src/go/build/syslist.go b/src/go/build/syslist.go
index 2c2cac9..5e907dd 100644
--- a/src/go/build/syslist.go
+++ b/src/go/build/syslist.go
@@ -4,5 +4,5 @@
 
 package build
 
-const goosList = "android darwin dragonfly freebsd linux nacl netbsd openbsd plan9 solaris windows "
+const goosList = "android darwin dragonfly freebsd linux nacl netbsd openbsd plan9 solaris windows clive"
 const goarchList = "386 amd64 amd64p32 arm arm64 ppc64 ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc s390 s390x sparc sparc64 "
diff --git a/src/net/internal/socktest/skip.go b/src/net/internal/socktest/skip.go
new file mode 100644
index 0000000..b1177ff
--- /dev/null
+++ b/src/net/internal/socktest/skip.go
@@ -0,0 +1,3 @@
+// +build !clive 
+
+package socktest
diff --git a/src/net/iprawsock_clive.go b/src/net/iprawsock_clive.go
new file mode 100644
index 0000000..40a9e6c
--- /dev/null
+++ b/src/net/iprawsock_clive.go
@@ -0,0 +1,84 @@
+// Copyright 2010 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build clive
+
+package net
+
+import (
+	"syscall"
+	"time"
+)
+
+// IPConn is the implementation of the Conn and PacketConn interfaces
+// for IP network connections.
+type IPConn struct {
+	conn
+}
+
+// ReadFromIP reads an IP packet from c, copying the payload into b.
+// It returns the number of bytes copied into b and the return address
+// that was on the packet.
+//
+// ReadFromIP can be made to time out and return an error with
+// Timeout() == true after a fixed time limit; see SetDeadline and
+// SetReadDeadline.
+func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error) {
+	return 0, nil, &OpError{Op: "read", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+
+// ReadFrom implements the PacketConn ReadFrom method.
+func (c *IPConn) ReadFrom(b []byte) (int, Addr, error) {
+	return 0, nil, &OpError{Op: "read", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+
+// ReadMsgIP reads a packet from c, copying the payload into b and the
+// associated out-of-band data into oob.  It returns the number of
+// bytes copied into b, the number of bytes copied into oob, the flags
+// that were set on the packet and the source address of the packet.
+func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error) {
+	return 0, 0, 0, nil, &OpError{Op: "read", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+
+// WriteToIP writes an IP packet to addr via c, copying the payload
+// from b.
+//
+// WriteToIP can be made to time out and return an error with
+// Timeout() == true after a fixed time limit; see SetDeadline and
+// SetWriteDeadline.  On packet-oriented connections, write timeouts
+// are rare.
+func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error) {
+	return 0, &OpError{Op: "write", Net: c.fd.dir, Source: c.fd.laddr, Addr: addr, Err: syscall.ECLIVE}
+}
+
+// WriteTo implements the PacketConn WriteTo method.
+func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error) {
+	return 0, &OpError{Op: "write", Net: c.fd.dir, Source: c.fd.laddr, Addr: addr, Err: syscall.ECLIVE}
+}
+
+// WriteMsgIP writes a packet to addr via c, copying the payload from
+// b and the associated out-of-band data from oob.  It returns the
+// number of payload and out-of-band bytes written.
+func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error) {
+	return 0, 0, &OpError{Op: "write", Net: c.fd.dir, Source: c.fd.laddr, Addr: addr, Err: syscall.ECLIVE}
+}
+
+// DialIP connects to the remote address raddr on the network protocol
+// netProto, which must be "ip", "ip4", or "ip6" followed by a colon
+// and a protocol number or name.
+func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error) {
+	return dialIP(netProto, laddr, raddr, noDeadline)
+}
+
+func dialIP(netProto string, laddr, raddr *IPAddr, deadline time.Time) (*IPConn, error) {
+	return nil, &OpError{Op: "dial", Net: netProto, Source: laddr, Addr: raddr, Err: syscall.ECLIVE}
+}
+
+// ListenIP listens for incoming IP packets addressed to the local
+// address laddr.  The returned connection's ReadFrom and WriteTo
+// methods can be used to receive and send IP packets with per-packet
+// addressing.
+func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error) {
+	return nil, &OpError{Op: "listen", Net: netProto, Source: nil, Addr: laddr, Err: syscall.ECLIVE}
+}
diff --git a/src/net/net_clive.go b/src/net/net_clive.go
new file mode 100644
index 0000000..c2c6b40
--- /dev/null
+++ b/src/net/net_clive.go
@@ -0,0 +1,178 @@
+// +build clive
+
+package net
+
+import (
+	"errors"
+	"time"
+	"syscall"
+	"os"
+)
+
+// TCPConn is an implementation of the Conn interface for TCP network
+// connections.
+type TCPConn struct {
+	conn
+}
+// UDPConn is the implementation of the Conn and PacketConn interfaces
+// for UDP network connections.
+type UDPConn struct {
+	conn
+}
+
+var errBug = errors.New("bug")
+
+type netFD struct {
+	dir          string	// used for errors
+	laddr, raddr Addr	// used for errors
+	net          string	// used for errors
+}
+
+// TCPListener is a TCP network listener.  Clients should typically
+// use variables of type Listener instead of assuming TCP.
+type TCPListener struct {
+}
+
+func sysInit() {}
+func probeIPv4Stack() bool { return false }
+func probeIPv6Stack() (bool, bool) { return false, false }
+
+func lookupProtocol(name string) (proto int, err error) { return 0, errBug }
+func dial(net string, ra Addr, dialer func(time.Time) (Conn, error), deadline time.Time) (c Conn, err error) {
+	err = errBug
+	return
+}
+func setKeepAlive(fd *netFD, keepalive bool) error { return errBug }
+func setKeepAlivePeriod(fd *netFD, d time.Duration) error { return errBug }
+func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error) {
+	return dialTCP(net, laddr, raddr, noDeadline)
+}
+func dialTCP(net string, laddr, raddr *TCPAddr, deadline time.Time) (*TCPConn, error) {
+	return nil, errBug
+}
+func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error) {
+	return dialUDP(net, laddr, raddr, noDeadline)
+}
+func dialUDP(net string, laddr, raddr *UDPAddr, deadline time.Time) (*UDPConn, error) {
+	return nil, errBug
+}
+func maxListenerBacklog() int {
+	return 5
+}
+func fileListener(f *os.File) (Listener, error) {
+	return nil, errBug
+}
+// ListenTCP announces on the TCP address laddr and returns a TCP
+// listener.  Net must be "tcp", "tcp4", or "tcp6".  If laddr has a
+// port of 0, ListenTCP will choose an available port.  The caller can
+// use the Addr method of TCPListener to retrieve the chosen address.
+func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error) {
+	return nil, errBug
+}
+// ListenUDP listens for incoming UDP packets addressed to the local
+// address laddr.  Net must be "udp", "udp4", or "udp6".  If laddr has
+// a port of 0, ListenUDP will choose an available port.
+// The LocalAddr method of the returned UDPConn can be used to
+// discover the port.  The returned connection's ReadFrom and WriteTo
+// methods can be used to receive and send UDP packets with per-packet
+// addressing.
+func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error) {
+	return nil, errBug
+}
+
+func fileConn(f *os.File) (c Conn, err error) {
+	err = errBug
+	return
+}
+func filePacketConn(f *os.File) (c PacketConn, err error) {
+	err = errBug
+	return
+}
+// ReadFrom implements the PacketConn ReadFrom method.
+func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error) {
+	return 0, nil, &OpError{Op: "read", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+// ReadFrom implements the PacketConn ReadFrom method.
+func (c *TCPConn) ReadFrom(b []byte) (int, Addr, error) {
+	return 0, nil, &OpError{Op: "read", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+// WriteTo implements the PacketConn WriteTo method.
+func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error) {
+	return 0, &OpError{Op: "write", Net: c.fd.dir, Source: c.fd.laddr, Addr: addr, Err: syscall.ECLIVE}
+}
+
+// WriteTo implements the PacketConn WriteTo method.
+func (c *TCPConn) WriteTo(b []byte, addr Addr) (int, error) {
+	return 0, &OpError{Op: "write", Net: c.fd.dir, Source: c.fd.laddr, Addr: addr, Err: syscall.ECLIVE}
+}
+func (c *TCPConn) CloseWrite() error {
+	return errBug
+}
+func socketConn(f *os.File, sa SocketAddr) (Conn, error) {
+	return nil, syscall.ECLIVE
+}
+
+func socketPacketConn(f *os.File, sa SocketAddr) (PacketConn, error) {
+	return nil, syscall.ECLIVE
+}
+
+func (l *TCPListener) Accept() (c Conn, err error) {
+	return nil, syscall.ECLIVE
+}
+func (l *TCPListener) AcceptTCP() (*TCPConn, error) {
+	return nil, syscall.ECLIVE
+}
+func (c *TCPConn) SetKeepAlive(keepalive bool) error {
+	return syscall.ECLIVE
+}
+func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error {
+	return syscall.ECLIVE
+}
+func (l *TCPListener) Addr() Addr { return nil }
+func (l *TCPListener) Close() error { return syscall.ECLIVE }
+func interfaceAddrTable(ifi *Interface) ([]Addr, error) { return nil, syscall.ECLIVE }
+func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error) { return nil, syscall.ECLIVE }
+func interfaceTable(ifindex int) ([]Interface, error) { return nil, syscall.ECLIVE }
+func lookupHost(host string) (addrs []string, err error) { return nil, syscall.ECLIVE }
+func lookupIP(host string) (addrs []IPAddr, err error) { return nil, syscall.ECLIVE }
+func lookupPort(network, service string) (port int, err error) { return 0, syscall.ECLIVE }
+func lookupCNAME(name string) (cname string, err error) {return "", syscall.ECLIVE}
+func lookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {
+	return "", nil, syscall.ECLIVE
+}
+func lookupMX(name string) (mx []*MX, err error) { return nil, syscall.ECLIVE }
+func lookupNS(name string) (ns []*NS, err error) { return nil, syscall.ECLIVE }
+func lookupTXT(name string) (txt []string, err error) { return nil, syscall.ECLIVE }
+func lookupAddr(addr string) (name []string, err error) { return nil, syscall.ECLIVE }
+
+func (fd *netFD) Read(b []byte) (n int, err error) {
+	return 0, syscall.ECLIVE
+}
+func (fd *netFD) Write(b []byte) (n int, err error) {
+	return 0, syscall.ECLIVE
+}
+func (fd *netFD) Close() error {
+	return syscall.ECLIVE
+}
+func (fd *netFD) setDeadline(t time.Time) error {
+	return syscall.ECLIVE
+}
+func (fd *netFD) setReadDeadline(t time.Time) error {
+	return syscall.ECLIVE
+}
+
+func (fd *netFD) setWriteDeadline(t time.Time) error {
+	return syscall.ECLIVE
+}
+
+func setReadBuffer(fd *netFD, bytes int) error {
+	return syscall.ECLIVE
+}
+
+func setWriteBuffer(fd *netFD, bytes int) error {
+	return syscall.ECLIVE
+}
+
+func (fd *netFD) dup() (*os.File, error) {
+	return nil, syscall.ECLIVE
+}
diff --git a/src/net/unixsock_clive.go b/src/net/unixsock_clive.go
new file mode 100644
index 0000000..d4c7430
--- /dev/null
+++ b/src/net/unixsock_clive.go
@@ -0,0 +1,150 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build clive
+
+
+package net
+
+import (
+	"os"
+	"syscall"
+	"time"
+)
+
+// UnixConn is an implementation of the Conn interface for connections
+// to Unix domain sockets.
+type UnixConn struct {
+	conn
+}
+
+// ReadFromUnix reads a packet from c, copying the payload into b.  It
+// returns the number of bytes copied into b and the source address of
+// the packet.
+//
+// ReadFromUnix can be made to time out and return an error with
+// Timeout() == true after a fixed time limit; see SetDeadline and
+// SetReadDeadline.
+func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error) {
+	return 0, nil, &OpError{Op: "read", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+
+// ReadFrom implements the PacketConn ReadFrom method.
+func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error) {
+	return 0, nil, &OpError{Op: "read", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+
+// ReadMsgUnix reads a packet from c, copying the payload into b and
+// the associated out-of-band data into oob.  It returns the number of
+// bytes copied into b, the number of bytes copied into oob, the flags
+// that were set on the packet, and the source address of the packet.
+func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error) {
+	return 0, 0, 0, nil, &OpError{Op: "read", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+
+// WriteToUnix writes a packet to addr via c, copying the payload from b.
+//
+// WriteToUnix can be made to time out and return an error with
+// Timeout() == true after a fixed time limit; see SetDeadline and
+// SetWriteDeadline.  On packet-oriented connections, write timeouts
+// are rare.
+func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error) {
+	return 0, &OpError{Op: "write", Net: c.fd.dir, Source: c.fd.laddr, Addr: addr, Err: syscall.ECLIVE}
+}
+
+// WriteTo implements the PacketConn WriteTo method.
+func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error) {
+	return 0, &OpError{Op: "write", Net: c.fd.dir, Source: c.fd.laddr, Addr: addr, Err: syscall.ECLIVE}
+}
+
+// WriteMsgUnix writes a packet to addr via c, copying the payload
+// from b and the associated out-of-band data from oob.  It returns
+// the number of payload and out-of-band bytes written.
+func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error) {
+	return 0, 0, &OpError{Op: "write", Net: c.fd.dir, Source: c.fd.laddr, Addr: addr, Err: syscall.ECLIVE}
+}
+
+// CloseRead shuts down the reading side of the Unix domain connection.
+// Most callers should just use Close.
+func (c *UnixConn) CloseRead() error {
+	return &OpError{Op: "close", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+
+// CloseWrite shuts down the writing side of the Unix domain connection.
+// Most callers should just use Close.
+func (c *UnixConn) CloseWrite() error {
+	return &OpError{Op: "close", Net: c.fd.dir, Source: c.fd.laddr, Addr: c.fd.raddr, Err: syscall.ECLIVE}
+}
+
+// DialUnix connects to the remote address raddr on the network net,
+// which must be "unix", "unixgram" or "unixpacket".  If laddr is not
+// nil, it is used as the local address for the connection.
+func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error) {
+	return dialUnix(net, laddr, raddr, noDeadline)
+}
+
+func dialUnix(net string, laddr, raddr *UnixAddr, deadline time.Time) (*UnixConn, error) {
+	return nil, &OpError{Op: "dial", Net: net, Source: laddr, Addr: raddr, Err: syscall.ECLIVE}
+}
+
+// UnixListener is a Unix domain socket listener.  Clients should
+// typically use variables of type Listener instead of assuming Unix
+// domain sockets.
+type UnixListener struct {
+	fd *netFD
+}
+
+// ListenUnix announces on the Unix domain socket laddr and returns a
+// Unix listener.  The network net must be "unix" or "unixpacket".
+func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error) {
+	return nil, &OpError{Op: "listen", Net: net, Source: nil, Addr: laddr, Err: syscall.ECLIVE}
+}
+
+// AcceptUnix accepts the next incoming call and returns the new
+// connection.
+func (l *UnixListener) AcceptUnix() (*UnixConn, error) {
+	return nil, &OpError{Op: "accept", Net: l.fd.dir, Source: nil, Addr: l.fd.laddr, Err: syscall.ECLIVE}
+}
+
+// Accept implements the Accept method in the Listener interface; it
+// waits for the next call and returns a generic Conn.
+func (l *UnixListener) Accept() (Conn, error) {
+	return nil, &OpError{Op: "accept", Net: l.fd.dir, Source: nil, Addr: l.fd.laddr, Err: syscall.ECLIVE}
+}
+
+// Close stops listening on the Unix address.  Already accepted
+// connections are not closed.
+func (l *UnixListener) Close() error {
+	return &OpError{Op: "close", Net: l.fd.dir, Source: nil, Addr: l.fd.laddr, Err: syscall.ECLIVE}
+}
+
+// Addr returns the listener's network address.
+// The Addr returned is shared by all invocations of Addr, so
+// do not modify it.
+func (l *UnixListener) Addr() Addr { return nil }
+
+// SetDeadline sets the deadline associated with the listener.
+// A zero time value disables the deadline.
+func (l *UnixListener) SetDeadline(t time.Time) error {
+	return &OpError{Op: "set", Net: l.fd.dir, Source: nil, Addr: l.fd.laddr, Err: syscall.ECLIVE}
+}
+
+// File returns a copy of the underlying os.File, set to blocking
+// mode.  It is the caller's responsibility to close f when finished.
+// Closing l does not affect f, and closing f does not affect l.
+//
+// The returned os.File's file descriptor is different from the
+// connection's.  Attempting to change properties of the original
+// using this duplicate may or may not have the desired effect.
+func (l *UnixListener) File() (*os.File, error) {
+	return nil, &OpError{Op: "file", Net: l.fd.dir, Source: nil, Addr: l.fd.laddr, Err: syscall.ECLIVE}
+}
+
+// ListenUnixgram listens for incoming Unix datagram packets addressed
+// to the local address laddr.  The network net must be "unixgram".
+// The returned connection's ReadFrom and WriteTo methods can be used
+// to receive and send packets with per-packet addressing.
+func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error) {
+	return nil, &OpError{Op: "listen", Net: net, Source: nil, Addr: laddr, Err: syscall.ECLIVE}
+}
diff --git a/src/os/exec/lp_clive.go b/src/os/exec/lp_clive.go
new file mode 100644
index 0000000..e9adb2d
--- /dev/null
+++ b/src/os/exec/lp_clive.go
@@ -0,0 +1,55 @@
+// Copyright 2011 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build clive
+
+package exec
+
+import (
+	"errors"
+	"os"
+	"strings"
+)
+
+// ErrNotFound is the error resulting if a path search failed to find an executable file.
+var ErrNotFound = errors.New("executable file not found in $path")
+
+func findExecutable(file string) error {
+	d, err := os.Stat(file)
+	if err != nil {
+		return err
+	}
+	if m := d.Mode(); !m.IsDir() && m&0111 != 0 {
+		return nil
+	}
+	return os.ErrPermission
+}
+
+// LookPath searches for an executable binary named file
+// in the directories named by the path environment variable.
+// If file begins with "/", "#", "./", or "../", it is tried
+// directly and the path is not consulted.
+// The result may be an absolute path or a path relative to the current directory.
+func LookPath(file string) (string, error) {
+	// skip the path lookup for these prefixes
+	skip := []string{"/", "#", "./", "../"}
+
+	for _, p := range skip {
+		if strings.HasPrefix(file, p) {
+			err := findExecutable(file)
+			if err == nil {
+				return file, nil
+			}
+			return "", &Error{file, err}
+		}
+	}
+
+	path := os.Getenv("path")
+	for _, dir := range strings.Split(path, "\000") {
+		if err := findExecutable(dir + "/" + file); err == nil {
+			return dir + "/" + file, nil
+		}
+	}
+	return "", &Error{file, ErrNotFound}
+}
diff --git a/src/os/signal/signal_clive.go b/src/os/signal/signal_clive.go
new file mode 100644
index 0000000..16f6558
--- /dev/null
+++ b/src/os/signal/signal_clive.go
@@ -0,0 +1,59 @@
+// Copyright 2012 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build clive
+
+package signal
+
+import (
+	"os"
+	"syscall"
+)
+
+var sigtab = make(map[os.Signal]int)
+
+// In sig.s; jumps to runtime.
+func signal_disable(uint32)
+func signal_enable(uint32)
+func signal_ignore(uint32)
+func signal_recv() string
+
+func init() {
+	signal_enable(0) // first call - initialize
+	// go func() {
+	//	process(syscall.Note(signal_recv()))
+	// }
+}
+
+
+const numSig = 256
+
+func signum(sig os.Signal) int {
+	switch sig := sig.(type) {
+	case syscall.Note:
+		n, ok := sigtab[sig]
+		if !ok {
+			n = len(sigtab) + 1
+			if n > numSig {
+				return -1
+			}
+			sigtab[sig] = n
+		}
+		return n
+	default:
+		return -1
+	}
+}
+
+func enableSignal(sig int) {
+	signal_enable(uint32(sig))
+}
+
+func disableSignal(sig int) {
+	signal_disable(uint32(sig))
+}
+
+func ignoreSignal(sig int) {
+	signal_ignore(uint32(sig))
+}
diff --git a/src/os/sys_clive.go b/src/os/sys_clive.go
new file mode 100644
index 0000000..42fc06b
--- /dev/null
+++ b/src/os/sys_clive.go
@@ -0,0 +1,129 @@
+// +build clive
+
+package os
+
+import (
+	"errors"
+	"time"
+	"syscall"
+)
+
+type dirInfo struct{}
+
+type File struct {
+	fd int
+	name string
+
+	dirinfo *dirInfo // nil unless directory being read // used by seek and others
+}
+
+type ProcessState {}	// Wait
+
+const (
+	PathSeparator     = '/'    // OS-specific path separator
+	PathListSeparator = ':' // OS-specific path list separator
+	DevNull = "/dev/null"
+)
+
+var errBug = errors.New("bug")
+
+var (
+	Interrupt Signal = syscall.Note("interrupt")
+	Kill      Signal = syscall.Note("kill")
+)
+
+func NewFile(fd uintptr, name string) *File { return &File{fd: int(fd), name: name} }
+func findProcess(pid int) (p *Process, err error) { return nil, errBug }
+func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) { return nil, errBug }
+func (p *Process) release() error { return errBug }
+func (p *Process) kill() error { return errBug }
+func (p *Process) wait() (ps *ProcessState, err error) { return nil, errBug }
+func (p *Process) signal(sig Signal) error { return errBug }
+func (p *ProcessState) userTime() time.Duration { return 0 }
+func (p *ProcessState) systemTime() time.Duration { return 0 }
+func (p *ProcessState) String() string { return "exit status" }
+func (p *ProcessState) exited() bool { return false }
+func (p *ProcessState) success() bool { return false }
+func (p *ProcessState) sysUsage() interface{} { return "exit status" }
+func (p *ProcessState) sys() interface{} {return "exit status" }
+
+func hostname() (name string, err error) { return "atlantis", nil }
+
+func (f *File) readdir(n int) (fi []FileInfo, err error) { return nil, errBug }
+func (file *File) readdirnames(n int) (names []string, err error) { return nil, errBug }
+func (f *File) read(b []byte) (n int, err error) { return 0, errBug }
+func (f *File) pread(b []byte, off int64) (n int, err error) {return 0, errBug }
+func (f *File) write(b []byte) (n int, err error) { return 0, errBug }
+func (f *File) pwrite(b []byte, off int64) (n int, err error) { return 0, errBug }
+func (f *File) seek(offset int64, whence int) (ret int64, err error) { return 0, errBug }
+func epipecheck(file *File, e error) {}
+func (f *File) Chmod(mode FileMode) error { return errBug }
+func Chmod(name string, mode FileMode) error { return errBug }
+func OpenFile(name string, flag int, perm FileMode) (file *File, err error) { return nil, errBug }
+func Lstat(name string) (fi FileInfo, err error) { return nil, errBug }
+func rename(oldname, newname string) error { return errBug }
+func syscallMode(i FileMode) (o uint32) { return uint32(i.Perm()) }
+func Stat(name string) (fi FileInfo, err error) { return nil, errBug }
+func (f *File) Stat() (fi FileInfo, err error) { return nil, errBug }
+func (f *File) Close() error { return errBug }
+func Remove(name string) error { return errBug }
+func sameFile(fs1, fs2 *fileStat) bool { return false }
+func Readlink(name string) (string, error) { return "", errBug }
+func TempDir() string { return "" }
+func Pipe() (r *File, w *File, err error) { return nil, nil, errBug }
+func Chtimes(name string, atime time.Time, mtime time.Time) error { return errBug }
+func Truncate(name string, size int64) error { return errBug }
+func (f *File) Truncate(size int64) error { return errBug }
+
+func isExist(err error) bool {
+	switch pe := err.(type) {
+	case nil:
+		return false
+	case *PathError:
+		err = pe.Err
+	case *LinkError:
+		err = pe.Err
+	}
+	return contains(err.Error(), " exists")
+}
+
+func isNotExist(err error) bool {
+	switch pe := err.(type) {
+	case nil:
+		return false
+	case *PathError:
+		err = pe.Err
+	case *LinkError:
+		err = pe.Err
+	}
+	return contains(err.Error(), "does not exist") || contains(err.Error(), "not found") ||
+		contains(err.Error(), "has been removed") || contains(err.Error(), "no parent")
+}
+
+func isPermission(err error) bool {
+	switch pe := err.(type) {
+	case nil:
+		return false
+	case *PathError:
+		err = pe.Err
+	case *LinkError:
+		err = pe.Err
+	}
+	return contains(err.Error(), "permission denied")
+}
+
+// contains is a local version of strings.Contains. It knows len(sep) > 1.
+func contains(s, sep string) bool {
+	n := len(sep)
+	c := sep[0]
+	for i := 0; i+n <= len(s); i++ {
+		if s[i] == c && s[i:i+n] == sep {
+			return true
+		}
+	}
+	return false
+}
+
+func IsPathSeparator(c uint8) bool {
+	return PathSeparator == c
+}
diff --git a/src/path/filepath/path_clive.go b/src/path/filepath/path_clive.go
new file mode 100644
index 0000000..2e596e5
--- /dev/null
+++ b/src/path/filepath/path_clive.go
@@ -0,0 +1,46 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build clive
+
+package filepath
+
+import "strings"
+
+// IsAbs reports whether the path is absolute.
+func IsAbs(path string) bool {
+	return strings.HasPrefix(path, "/") || strings.HasPrefix(path, "#")
+}
+
+// volumeNameLen returns length of the leading volume name on Windows.
+// It returns 0 elsewhere.
+func volumeNameLen(path string) int {
+	return 0
+}
+
+// HasPrefix exists for historical compatibility and should not be used.
+func HasPrefix(p, prefix string) bool {
+	return strings.HasPrefix(p, prefix)
+}
+
+func splitList(path string) []string {
+	if path == "" {
+		return []string{}
+	}
+	return strings.Split(path, string(ListSeparator))
+}
+
+func abs(path string) (string, error) {
+	return unixAbs(path)
+}
+
+func join(elem []string) string {
+	// If there's a bug here, fix the logic in ./path_unix.go too.
+	for i, e := range elem {
+		if e != "" {
+			return Clean(strings.Join(elem[i:], string(Separator)))
+		}
+	}
+	return ""
+}
diff --git a/src/runtime/cgo/skip.go b/src/runtime/cgo/skip.go
new file mode 100644
index 0000000..f642cd2
--- /dev/null
+++ b/src/runtime/cgo/skip.go
@@ -0,0 +1,4 @@
+// +build !clive
+
+package cgo
+
diff --git a/src/runtime/sys_clive.go b/src/runtime/sys_clive.go
new file mode 100644
index 0000000..32dc43a
--- /dev/null
+++ b/src/runtime/sys_clive.go
@@ -0,0 +1,65 @@
+// +build clive
+
+package runtime
+
+
+// Stuff needed to make the clive port.
+
+import "unsafe"
+
+const (
+	_NSIG   = 1  // number of signals in sigtable array
+	active_spin = 4
+	active_spin_cnt = 30
+)
+
+type sigTabT struct {
+	flags int32
+	name  string
+}
+
+var sigtable = [...]sigTabT {
+	/* 0 */ {0, "SIGNONE: no trap"},
+}
+
+func mpreinit(mp *m) {}
+func minit() {}
+func unminit() {}
+func initsig() {}
+func netpoll(block bool) *g { return nil }
+func netpollinited() bool { return false }
+
+func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {return nil}
+func sysFree(v unsafe.Pointer, n uintptr, sysStat *uint64) {}
+func sysReserve(v unsafe.Pointer, n uintptr, reserved *bool) unsafe.Pointer { return nil }
+func sysUnused(v unsafe.Pointer, n uintptr) {}
+func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64) {}
+func sysUsed(v unsafe.Pointer, n uintptr) {}
+
+func lock(l *mutex) {}
+func unlock(l *mutex) {}
+func osyield() {}
+
+func newosproc(mp *m, stk unsafe.Pointer) {}
+
+func noteclear(n *note) {}
+func notetsleep(n *note, ns int64) bool { return false }
+func notewakeup(n *note) {}
+func notetsleepg(n *note, ns int64) bool { return false }
+func msigsave(mp *m) {}
+func notesleep(n *note) {}
+func resetcpuprofiler(hz int32) {}
+func sigpanic() {}
+func sigenable(sig uint32) {}
+func sigdisable(sig uint32) {}
+func sigignore(sig uint32) {}
+func crash() {}
+func sysFault(v unsafe.Pointer, n uintptr) {}
+
+func getRandomData(r []byte) {}
+
+func goenvs() {}
+func gogetenv(key string) string { return "" }
+
+var _cgo_setenv unsafe.Pointer   // pointer to C function; used to update the C env
+var _cgo_unsetenv unsafe.Pointer // pointer to C function
diff --git a/src/runtime/zgoarch_386.go b/src/runtime/zgoarch_386.go
index 79053f1..620569a 100644
--- a/src/runtime/zgoarch_386.go
+++ b/src/runtime/zgoarch_386.go
@@ -11,3 +11,14 @@ const goarch_arm = 0
 const goarch_arm64 = 0
 const goarch_ppc64 = 0
 const goarch_ppc64le = 0
+const goarch_mips = 0
+const goarch_mipsle = 0
+const goarch_mips64 = 0
+const goarch_mips64le = 0
+const goarch_mips64p32 = 0
+const goarch_mips64p32le = 0
+const goarch_ppc = 0
+const goarch_s390 = 0
+const goarch_s390x = 0
+const goarch_sparc = 0
+const goarch_sparc64 = 0
diff --git a/src/runtime/zgoarch_amd64.go b/src/runtime/zgoarch_amd64.go
index 70095f5..c667095 100644
--- a/src/runtime/zgoarch_amd64.go
+++ b/src/runtime/zgoarch_amd64.go
@@ -11,3 +11,14 @@ const goarch_arm = 0
 const goarch_arm64 = 0
 const goarch_ppc64 = 0
 const goarch_ppc64le = 0
+const goarch_mips = 0
+const goarch_mipsle = 0
+const goarch_mips64 = 0
+const goarch_mips64le = 0
+const goarch_mips64p32 = 0
+const goarch_mips64p32le = 0
+const goarch_ppc = 0
+const goarch_s390 = 0
+const goarch_s390x = 0
+const goarch_sparc = 0
+const goarch_sparc64 = 0
diff --git a/src/runtime/zgoarch_amd64p32.go b/src/runtime/zgoarch_amd64p32.go
index 9ac3f0b..3b1111d 100644
--- a/src/runtime/zgoarch_amd64p32.go
+++ b/src/runtime/zgoarch_amd64p32.go
@@ -11,3 +11,14 @@ const goarch_arm = 0
 const goarch_arm64 = 0
 const goarch_ppc64 = 0
 const goarch_ppc64le = 0
+const goarch_mips = 0
+const goarch_mipsle = 0
+const goarch_mips64 = 0
+const goarch_mips64le = 0
+const goarch_mips64p32 = 0
+const goarch_mips64p32le = 0
+const goarch_ppc = 0
+const goarch_s390 = 0
+const goarch_s390x = 0
+const goarch_sparc = 0
+const goarch_sparc64 = 0
diff --git a/src/runtime/zgoarch_arm.go b/src/runtime/zgoarch_arm.go
index c865dc0..2d2f9df 100644
--- a/src/runtime/zgoarch_arm.go
+++ b/src/runtime/zgoarch_arm.go
@@ -11,3 +11,14 @@ const goarch_arm = 1
 const goarch_arm64 = 0
 const goarch_ppc64 = 0
 const goarch_ppc64le = 0
+const goarch_mips = 0
+const goarch_mipsle = 0
+const goarch_mips64 = 0
+const goarch_mips64le = 0
+const goarch_mips64p32 = 0
+const goarch_mips64p32le = 0
+const goarch_ppc = 0
+const goarch_s390 = 0
+const goarch_s390x = 0
+const goarch_sparc = 0
+const goarch_sparc64 = 0
diff --git a/src/runtime/zgoarch_arm64.go b/src/runtime/zgoarch_arm64.go
index cde5e9f..7569200 100644
--- a/src/runtime/zgoarch_arm64.go
+++ b/src/runtime/zgoarch_arm64.go
@@ -11,3 +11,14 @@ const goarch_arm = 0
 const goarch_arm64 = 1
 const goarch_ppc64 = 0
 const goarch_ppc64le = 0
+const goarch_mips = 0
+const goarch_mipsle = 0
+const goarch_mips64 = 0
+const goarch_mips64le = 0
+const goarch_mips64p32 = 0
+const goarch_mips64p32le = 0
+const goarch_ppc = 0
+const goarch_s390 = 0
+const goarch_s390x = 0
+const goarch_sparc = 0
+const goarch_sparc64 = 0
diff --git a/src/runtime/zgoarch_ppc64.go b/src/runtime/zgoarch_ppc64.go
index 13d87d9..f74f3ce 100644
--- a/src/runtime/zgoarch_ppc64.go
+++ b/src/runtime/zgoarch_ppc64.go
@@ -11,3 +11,14 @@ const goarch_arm = 0
 const goarch_arm64 = 0
 const goarch_ppc64 = 1
 const goarch_ppc64le = 0
+const goarch_mips = 0
+const goarch_mipsle = 0
+const goarch_mips64 = 0
+const goarch_mips64le = 0
+const goarch_mips64p32 = 0
+const goarch_mips64p32le = 0
+const goarch_ppc = 0
+const goarch_s390 = 0
+const goarch_s390x = 0
+const goarch_sparc = 0
+const goarch_sparc64 = 0
diff --git a/src/runtime/zgoarch_ppc64le.go b/src/runtime/zgoarch_ppc64le.go
index 5d088aa..3f1dd53 100644
--- a/src/runtime/zgoarch_ppc64le.go
+++ b/src/runtime/zgoarch_ppc64le.go
@@ -11,3 +11,14 @@ const goarch_arm = 0
 const goarch_arm64 = 0
 const goarch_ppc64 = 0
 const goarch_ppc64le = 1
+const goarch_mips = 0
+const goarch_mipsle = 0
+const goarch_mips64 = 0
+const goarch_mips64le = 0
+const goarch_mips64p32 = 0
+const goarch_mips64p32le = 0
+const goarch_ppc = 0
+const goarch_s390 = 0
+const goarch_s390x = 0
+const goarch_sparc = 0
+const goarch_sparc64 = 0
diff --git a/src/runtime/zgoos_android.go b/src/runtime/zgoos_android.go
index 0590bd9..5b48fd7 100644
--- a/src/runtime/zgoos_android.go
+++ b/src/runtime/zgoos_android.go
@@ -15,3 +15,4 @@ const goos_openbsd = 0
 const goos_plan9 = 0
 const goos_solaris = 0
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_clive.go b/src/runtime/zgoos_clive.go
new file mode 100644
index 0000000..7721a0e
--- /dev/null
+++ b/src/runtime/zgoos_clive.go
@@ -0,0 +1,19 @@
+// +build clive
+// generated by gengoos.go using 'go generate'
+
+package runtime
+
+const theGoos = `clive`
+
+const goos_android = 0
+const goos_darwin = 0
+const goos_dragonfly = 0
+const goos_freebsd = 0
+const goos_linux = 0
+const goos_nacl = 0
+const goos_netbsd = 0
+const goos_openbsd = 0
+const goos_plan9 = 0
+const goos_solaris = 0
+const goos_windows = 0
+const goos_clive = 1
diff --git a/src/runtime/zgoos_darwin.go b/src/runtime/zgoos_darwin.go
index c0a7cd6..620e373 100644
--- a/src/runtime/zgoos_darwin.go
+++ b/src/runtime/zgoos_darwin.go
@@ -15,3 +15,4 @@ const goos_openbsd = 0
 const goos_plan9 = 0
 const goos_solaris = 0
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_dragonfly.go b/src/runtime/zgoos_dragonfly.go
index 008d6de..343e45f 100644
--- a/src/runtime/zgoos_dragonfly.go
+++ b/src/runtime/zgoos_dragonfly.go
@@ -15,3 +15,4 @@ const goos_openbsd = 0
 const goos_plan9 = 0
 const goos_solaris = 0
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_freebsd.go b/src/runtime/zgoos_freebsd.go
index 2478940..4120ae9 100644
--- a/src/runtime/zgoos_freebsd.go
+++ b/src/runtime/zgoos_freebsd.go
@@ -15,3 +15,4 @@ const goos_openbsd = 0
 const goos_plan9 = 0
 const goos_solaris = 0
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_linux.go b/src/runtime/zgoos_linux.go
index c775ab5..2d56cf7 100644
--- a/src/runtime/zgoos_linux.go
+++ b/src/runtime/zgoos_linux.go
@@ -17,3 +17,4 @@ const goos_openbsd = 0
 const goos_plan9 = 0
 const goos_solaris = 0
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_nacl.go b/src/runtime/zgoos_nacl.go
index d9d88f4..402ff51 100644
--- a/src/runtime/zgoos_nacl.go
+++ b/src/runtime/zgoos_nacl.go
@@ -15,3 +15,4 @@ const goos_openbsd = 0
 const goos_plan9 = 0
 const goos_solaris = 0
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_netbsd.go b/src/runtime/zgoos_netbsd.go
index ff2c5cb..4e33036 100644
--- a/src/runtime/zgoos_netbsd.go
+++ b/src/runtime/zgoos_netbsd.go
@@ -15,3 +15,4 @@ const goos_openbsd = 0
 const goos_plan9 = 0
 const goos_solaris = 0
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_openbsd.go b/src/runtime/zgoos_openbsd.go
index b071dc6..35f20f8 100644
--- a/src/runtime/zgoos_openbsd.go
+++ b/src/runtime/zgoos_openbsd.go
@@ -15,3 +15,4 @@ const goos_openbsd = 1
 const goos_plan9 = 0
 const goos_solaris = 0
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_plan9.go b/src/runtime/zgoos_plan9.go
index 4306b0f..a0fbdb8 100644
--- a/src/runtime/zgoos_plan9.go
+++ b/src/runtime/zgoos_plan9.go
@@ -15,3 +15,4 @@ const goos_openbsd = 0
 const goos_plan9 = 1
 const goos_solaris = 0
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_solaris.go b/src/runtime/zgoos_solaris.go
index 10f9537..68551a6 100644
--- a/src/runtime/zgoos_solaris.go
+++ b/src/runtime/zgoos_solaris.go
@@ -15,3 +15,4 @@ const goos_openbsd = 0
 const goos_plan9 = 0
 const goos_solaris = 1
 const goos_windows = 0
+const goos_clive = 0
diff --git a/src/runtime/zgoos_windows.go b/src/runtime/zgoos_windows.go
index 56f5c58..4233ff2 100644
--- a/src/runtime/zgoos_windows.go
+++ b/src/runtime/zgoos_windows.go
@@ -15,3 +15,4 @@ const goos_openbsd = 0
 const goos_plan9 = 0
 const goos_solaris = 0
 const goos_windows = 1
+const goos_clive = 0
diff --git a/src/syscall/syscall_clive.go b/src/syscall/syscall_clive.go
new file mode 100644
index 0000000..2b165d9
--- /dev/null
+++ b/src/syscall/syscall_clive.go
@@ -0,0 +1,84 @@
+// +build clive
+
+package syscall
+
+var errBug = ErrorString("bug")
+
+type ErrorString string
+func (e ErrorString) Error() string { return string(e) }
+
+type Timeval struct {
+	Sec  int32
+	Usec int32
+}
+
+type Timespec struct {
+	Sec  int64
+	Nsec int64
+}
+
+type SysProcAttr struct {}
+
+
+const (
+	O_RDONLY                          = 0x0
+	O_WRONLY                          = 0x1
+	O_RDWR                            = 0x2
+	O_APPEND                          = 0x8
+	O_SYNC                            = 0x80
+	O_CREAT                           = 0x200
+	O_TRUNC                           = 0x400
+	O_EXCL                            = 0x800
+
+	ImplementsGetwd = false
+
+	SIGTERM = Note("term")
+	SIGUSR1 = Note("usr1")
+)
+
+// A Note is a string describing a process note.
+// It implements the os.Signal interface.
+type Note string
+
+func (n Note) Signal() {}
+
+func (n Note) String() string {
+	return string(n)
+}
+
+var (
+	EINVAL       = ErrorString("bad arg in system call")
+	EISDIR       = ErrorString("file is a directory")
+	ENAMETOOLONG = ErrorString("file name too long")
+	ENOTDIR      = ErrorString("not a directory")
+	ECLIVE      = ErrorString("go get a zx spectrum with 48K")
+	Stdin  = 0	// os/file.go calls NewFile(Stdin)... to init os.Stdin...
+	Stdout = 1
+	Stderr = 2
+)
+
+func Getenv(key string) (value string, found bool) { return "", false }
+func Setenv(key, value string) error { return errBug }
+func Unsetenv(key string) error { return errBug }
+func Clearenv() { }
+func Environ() []string { return nil }
+func Getpid() (pid int) { return 0 }
+func Getppid() (ppid int) { return 0 }
+func Mkdir(path string, mode uint32) (err error) { return errBug }
+func Chdir(path string) (err error) { return errBug }
+func Fchdir(fd int) (err error) { return errBug }
+func Getwd() (wd string, err error) { return "/", nil }
+func Getuid() (uid int)   { return -1 }
+func Geteuid() (euid int) { return -1 }
+func Getgid() (gid int)   { return -1 }
+func Getegid() (egid int) { return -1 }
+func Getgroups() (gids []int, err error) {
+	return make([]int, 0), nil
+}
+func Getpagesize() int { return 0x1000 }
+
+// Implemented in assembly to import from runtime.
+func exit(code int)
+
+func Exit(code int) { exit(code) }
+func Mkfifo(path string, mode uint32) (err error) { return errBug }
diff --git a/src/time/sys_clive.go b/src/time/sys_clive.go
new file mode 100644
index 0000000..1bd2043
--- /dev/null
+++ b/src/time/sys_clive.go
@@ -0,0 +1,16 @@
+// +build clive
+
+package time
+
+import (
+	"errors"
+)
+
+var errBug = errors.New("bug")
+
+func initLocal() {}
+func loadLocation(name string) (*Location, error) { return nil, errBug }
+func readFile(name string) ([]byte, error) { return nil, errBug }
+func open(name string) (uintptr, error) { return 0, errBug }
+func closefd(fd uintptr) {}
+func preadn(fd uintptr, buf []byte, off int) error { return errBug }
