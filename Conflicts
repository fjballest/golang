CONFLICT (content): Merge conflict in src/runtime/select.go
Auto-merging src/runtime/runtime2.go
CONFLICT (content): Merge conflict in src/runtime/runtime2.go
Auto-merging src/runtime/proc.go
CONFLICT (content): Merge conflict in src/runtime/proc.go
Auto-merging src/runtime/chan.go
CONFLICT (content): Merge conflict in src/runtime/chan.go
Removing src/runtime/cgo/gcc_libinit_linux_ppc64x.c
Auto-merging src/reflect/all_test.go
CONFLICT (content): Merge conflict in src/reflect/all_test.go
CONFLICT (modify/delete): src/go/types/testdata/stmt0.src deleted in HEAD and modified in go1.7.1. Version go1.7.1 of src/go/types/testdata/stmt0.src left in tree.
CONFLICT (modify/delete): src/go/types/testdata/gotos.src deleted in HEAD and modified in go1.7.1. Version go1.7.1 of src/go/types/testdata/gotos.src left in tree.
CONFLICT (content): Merge conflict in src/go/build/build_test.go
Auto-merging src/go/build/build.go
CONFLICT (content): Merge conflict in src/go/build/build.go
CONFLICT (content): Merge conflict in src/cmd/go/main.go
CONFLICT (content): Merge conflict in src/cmd/go/alldocs.go
CONFLICT (content): Merge conflict in src/cmd/compile/internal/gc/lex.go
CONFLICT (content): Merge conflict in src/cmd/compile/internal/gc/walk.go
CONFLICT (content): Merge conflict in src/cmd/compile/internal/gc/typecheck.go
CONFLICT (content): Merge conflict in src/cmd/compile/internal/gc/swt.go
CONFLICT (content): Merge conflict in src/cmd/compile/internal/gc/select.go
CONFLICT (content): Merge conflict in src/cmd/compile/internal/gc/parser.go
CONFLICT (content): Merge conflict in src/cmd/compile/internal/gc/inl.go
CONFLICT (content): Merge conflict in src/cmd/compile/internal/gc/builtin.go
CONFLICT (add/add): Merge conflict in VERSION

This was at lex.go:
<<<<<<< HEAD
	*val = int64(c)
	return false

hex:
	l := int64(0)
	for ; i > 0; i-- {
		c = getc()
		if c >= '0' && c <= '9' {
			l = l*16 + int64(c) - '0'
			continue
		}

		if c >= 'a' && c <= 'f' {
			l = l*16 + int64(c) - 'a' + 10
			continue
		}

		if c >= 'A' && c <= 'F' {
			l = l*16 + int64(c) - 'A' + 10
			continue
		}

		Yyerror("non-hex character in escape sequence: %c", c)
		ungetc(c)
		break
	}

	if u != 0 && (l > utf8.MaxRune || (0xd800 <= l && l < 0xe000)) {
		Yyerror("invalid Unicode code point in escape sequence: %#x", l)
		l = utf8.RuneError
	}

	*val = l
	return false
}

var syms = []struct {
	name    string
	lexical int
	etype   EType
	op      Op
}{
	// basic types
	{"int8", LNAME, TINT8, OXXX},
	{"int16", LNAME, TINT16, OXXX},
	{"int32", LNAME, TINT32, OXXX},
	{"int64", LNAME, TINT64, OXXX},
	{"uint8", LNAME, TUINT8, OXXX},
	{"uint16", LNAME, TUINT16, OXXX},
	{"uint32", LNAME, TUINT32, OXXX},
	{"uint64", LNAME, TUINT64, OXXX},
	{"float32", LNAME, TFLOAT32, OXXX},
	{"float64", LNAME, TFLOAT64, OXXX},
	{"complex64", LNAME, TCOMPLEX64, OXXX},
	{"complex128", LNAME, TCOMPLEX128, OXXX},
	{"bool", LNAME, TBOOL, OXXX},
	{"string", LNAME, TSTRING, OXXX},
	{"any", LNAME, TANY, OXXX},
	{"break", LBREAK, Txxx, OXXX},
	{"case", LCASE, Txxx, OXXX},
	{"chan", LCHAN, Txxx, OXXX},
	{"const", LCONST, Txxx, OXXX},
	{"continue", LCONTINUE, Txxx, OXXX},
	{"default", LDEFAULT, Txxx, OXXX},
	{"doselect", LDOSELECT, Txxx, OXXX},
	{"else", LELSE, Txxx, OXXX},
	{"defer", LDEFER, Txxx, OXXX},
	{"face", LINTERFACE, Txxx, OXXX},
	{"fallthrough", LFALL, Txxx, OXXX},
	{"for", LFOR, Txxx, OXXX},
	{"forsel", LDOSELECT, Txxx, OXXX},
	{"func", LFUNC, Txxx, OXXX},
	{"go", LGO, Txxx, OXXX},
	{"goto", LGOTO, Txxx, OXXX},
	{"if", LIF, Txxx, OXXX},
	{"import", LIMPORT, Txxx, OXXX},
	{"interface", LINTERFACE, Txxx, OXXX},
	{"map", LMAP, Txxx, OXXX},
	{"package", LPACKAGE, Txxx, OXXX},
	{"range", LRANGE, Txxx, OXXX},
	{"return", LRETURN, Txxx, OXXX},
	{"select", LSELECT, Txxx, OXXX},
	{"struct", LSTRUCT, Txxx, OXXX},
	{"switch", LSWITCH, Txxx, OXXX},
	{"type", LTYPE, Txxx, OXXX},
	{"var", LVAR, Txxx, OXXX},
	{"append", LNAME, Txxx, OAPPEND},
	{"cap", LNAME, Txxx, OCAP},
	{"cclosed", LNAME, Txxx, OCCLOSED},
	{"cerror", LNAME, Txxx, OCERROR},
	{"close", LNAME, Txxx, OCLOSE},
	{"complex", LNAME, Txxx, OCOMPLEX},
	{"copy", LNAME, Txxx, OCOPY},
	{"delete", LNAME, Txxx, ODELETE},
	{"imag", LNAME, Txxx, OIMAG},
	{"len", LNAME, Txxx, OLEN},
	{"make", LNAME, Txxx, OMAKE},
	{"new", LNAME, Txxx, ONEW},
	{"panic", LNAME, Txxx, OPANIC},
	{"print", LNAME, Txxx, OPRINT},
	{"println", LNAME, Txxx, OPRINTN},
	{"real", LNAME, Txxx, OREAL},
	{"recover", LNAME, Txxx, ORECOVER},
	{"notwithstanding", LIGNORE, Txxx, OXXX},
	{"thetruthofthematter", LIGNORE, Txxx, OXXX},
	{"despiteallobjections", LIGNORE, Txxx, OXXX},
	{"whereas", LIGNORE, Txxx, OXXX},
	{"insofaras", LIGNORE, Txxx, OXXX},
}

// lexinit initializes known symbols and the basic types.
func lexinit() {
	for _, s := range syms {
		lex := s.lexical
		s1 := Lookup(s.name)
		s1.Lexical = uint16(lex)

		if etype := s.etype; etype != Txxx {
			if int(etype) >= len(Types) {
				Fatalf("lexinit: %s bad etype", s.name)
			}
			s2 := Pkglookup(s.name, builtinpkg)
			t := Types[etype]
			if t == nil {
				t = typ(etype)
				t.Sym = s2

				if etype != TANY && etype != TSTRING {
					dowidth(t)
				}
				Types[etype] = t
			}

			s2.Lexical = LNAME
			s2.Def = typenod(t)
			s2.Def.Name = new(Name)
			continue
		}

		// TODO(marvin): Fix Node.EType type union.
		if etype := s.op; etype != OXXX {
			s2 := Pkglookup(s.name, builtinpkg)
			s2.Lexical = LNAME
			s2.Def = Nod(ONAME, nil, nil)
			s2.Def.Sym = s2
			s2.Def.Etype = EType(etype)
		}
	}

	// logically, the type of a string literal.
	// types[TSTRING] is the named type string
	// (the type of x in var x string or var x = "hello").
	// this is the ideal form
	// (the type of x in const x = "hello").
	idealstring = typ(TSTRING)

	idealbool = typ(TBOOL)

	s := Pkglookup("true", builtinpkg)
	s.Def = Nodbool(true)
	s.Def.Sym = Lookup("true")
	s.Def.Name = new(Name)
	s.Def.Type = idealbool

	s = Pkglookup("false", builtinpkg)
	s.Def = Nodbool(false)
	s.Def.Sym = Lookup("false")
	s.Def.Name = new(Name)
	s.Def.Type = idealbool

	s = Lookup("_")
	s.Block = -100
	s.Def = Nod(ONAME, nil, nil)
	s.Def.Sym = s
	Types[TBLANK] = typ(TBLANK)
	s.Def.Type = Types[TBLANK]
	nblank = s.Def

	s = Pkglookup("_", builtinpkg)
	s.Block = -100
	s.Def = Nod(ONAME, nil, nil)
	s.Def.Sym = s
	Types[TBLANK] = typ(TBLANK)
	s.Def.Type = Types[TBLANK]

	Types[TNIL] = typ(TNIL)
	s = Pkglookup("nil", builtinpkg)
	var v Val
	v.U = new(NilVal)
	s.Def = nodlit(v)
	s.Def.Sym = s
	s.Def.Name = new(Name)
}

func lexinit1() {
	// t = interface { Error() string }
	rcvr := typ(TSTRUCT)

	rcvr.Type = typ(TFIELD)
	rcvr.Type.Type = Ptrto(typ(TSTRUCT))
	rcvr.Funarg = true
	in := typ(TSTRUCT)
	in.Funarg = true
	out := typ(TSTRUCT)
	out.Type = typ(TFIELD)
	out.Type.Type = Types[TSTRING]
	out.Funarg = true
	f := typ(TFUNC)
	*getthis(f) = rcvr
	*Getoutarg(f) = out
	*getinarg(f) = in
	f.Thistuple = 1
	f.Intuple = 0
	f.Outnamed = false
	f.Outtuple = 1
	t := typ(TINTER)
	t.Type = typ(TFIELD)
	t.Type.Sym = Lookup("Error")
	t.Type.Type = f

	// error type
	s := Lookup("error")

	s.Lexical = LNAME
	s1 := Pkglookup("error", builtinpkg)
	errortype = t
	errortype.Sym = s1
	s1.Lexical = LNAME
	s1.Def = typenod(errortype)

	// byte alias
	s = Lookup("byte")

	s.Lexical = LNAME
	s1 = Pkglookup("byte", builtinpkg)
	bytetype = typ(TUINT8)
	bytetype.Sym = s1
	s1.Lexical = LNAME
	s1.Def = typenod(bytetype)
	s1.Def.Name = new(Name)

	// rune alias
	s = Lookup("rune")

	s.Lexical = LNAME
	s1 = Pkglookup("rune", builtinpkg)
	runetype = typ(TINT32)
	runetype.Sym = s1
	s1.Lexical = LNAME
	s1.Def = typenod(runetype)
	s1.Def.Name = new(Name)
}

func lexfini() {
	for i := range syms {
		lex := syms[i].lexical
		if lex != LNAME {
			continue
		}
		s := Lookup(syms[i].name)
		s.Lexical = uint16(lex)

		etype := syms[i].etype
		if etype != Txxx && (etype != TANY || Debug['A'] != 0) && s.Def == nil {
			s.Def = typenod(Types[etype])
			s.Def.Name = new(Name)
			s.Origpkg = builtinpkg
		}

		// TODO(marvin): Fix Node.EType type union.
		etype = EType(syms[i].op)
		if etype != EType(OXXX) && s.Def == nil {
			s.Def = Nod(ONAME, nil, nil)
			s.Def.Sym = s
			s.Def.Etype = etype
			s.Origpkg = builtinpkg
		}
	}

	// backend-specific builtin types (e.g. int).
	for i := range Thearch.Typedefs {
		s := Lookup(Thearch.Typedefs[i].Name)
		if s.Def == nil {
			s.Def = typenod(Types[Thearch.Typedefs[i].Etype])
			s.Def.Name = new(Name)
			s.Origpkg = builtinpkg
		}
	}

	// there's only so much table-driven we can handle.
	// these are special cases.
	if s := Lookup("byte"); s.Def == nil {
		s.Def = typenod(bytetype)
		s.Def.Name = new(Name)
		s.Origpkg = builtinpkg
	}

	if s := Lookup("error"); s.Def == nil {
		s.Def = typenod(errortype)
		s.Def.Name = new(Name)
		s.Origpkg = builtinpkg
	}

	if s := Lookup("rune"); s.Def == nil {
		s.Def = typenod(runetype)
		s.Def.Name = new(Name)
		s.Origpkg = builtinpkg
	}

	if s := Lookup("nil"); s.Def == nil {
		var v Val
		v.U = new(NilVal)
		s.Def = nodlit(v)
		s.Def.Sym = s
		s.Def.Name = new(Name)
		s.Origpkg = builtinpkg
	}

	if s := Lookup("iota"); s.Def == nil {
		s.Def = Nod(OIOTA, nil, nil)
		s.Def.Sym = s
		s.Origpkg = builtinpkg
	}

	if s := Lookup("true"); s.Def == nil {
		s.Def = Nodbool(true)
		s.Def.Sym = s
		s.Def.Name = new(Name)
		s.Origpkg = builtinpkg
	}

	if s := Lookup("false"); s.Def == nil {
		s.Def = Nodbool(false)
		s.Def.Sym = s
		s.Def.Name = new(Name)
		s.Origpkg = builtinpkg
	}

	nodfp = Nod(ONAME, nil, nil)
	nodfp.Type = Types[TINT32]
	nodfp.Xoffset = 0
	nodfp.Class = PPARAM
	nodfp.Sym = Lookup(".fp")
}

var lexn = map[int]string{
	LANDAND:    "ANDAND",
	LANDNOT:    "ANDNOT",
	LASOP:      "ASOP",
	LBREAK:     "BREAK",
	LCASE:      "CASE",
	LCHAN:      "CHAN",
	LCOLAS:     "COLAS",
	LCOMM:      "<-",
	LCONST:     "CONST",
	LCONTINUE:  "CONTINUE",
	LDDD:       "...",
	LDEC:       "DEC",
	LDEFAULT:   "DEFAULT",
	LDEFER:     "DEFER",
	LDOSELECT: "DOSELECT",
	LELSE:      "ELSE",
	LEQ:        "EQ",
	LFALL:      "FALL",
	LFOR:       "FOR",
	LFUNC:      "FUNC",
	LGE:        "GE",
	LGO:        "GO",
	LGOTO:      "GOTO",
	LGT:        "GT",
	LIF:        "IF",
	LIMPORT:    "IMPORT",
	LINC:       "INC",
	LINTERFACE: "INTERFACE",
	LLE:        "LE",
	LLITERAL:   "LITERAL",
	LLSH:       "LSH",
	LLT:        "LT",
	LMAP:       "MAP",
	LNAME:      "NAME",
	LNE:        "NE",
	LOROR:      "OROR",
	LPACKAGE:   "PACKAGE",
	LRANGE:     "RANGE",
	LRETURN:    "RETURN",
	LRSH:       "RSH",
	LSELECT:    "SELECT",
	LSTRUCT:    "STRUCT",
	LSWITCH:    "SWITCH",
	LTYPE:      "TYPE",
	LVAR:       "VAR",
}

func lexname(lex int) string {
	if s, ok := lexn[lex]; ok {
		return s
	}
	return fmt.Sprintf("LEX-%d", lex)
